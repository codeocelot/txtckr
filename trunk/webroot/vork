<?php error_reporting(E_ALL | E_STRICT);

define('DEBUG_MODE', false); //this is the only line that needs to be adjusted in this file

/**
 * Vork Framework www.Vork.us
 * @version 2.02
 * @author Eric David Benari, Vork Chief Architect
 */
class configInit {
    /**
     * Location of the packages folder (relative to webroot)
     */
    public static function packagesPath() {
         return configDefaults::basepath() . 'packages' . self::DS;
    }

    /**
     * Directory separator, in both Linux and Windows you can just leave this as-is
     */
    const DS = '/';

    /**
     * Creates the ability to access constants within inheriting classes just like properties
     * If there is a naming conflict properties take precedence, but this should never be
     * an issue when following standard Zend Framework/PEAR naming conventions where properties use
     * camel-caps and constants are all-capitals delimited by undersores.
     *
     * get::$config->myProperty
     * get::$config->MY_CONSTANT
     *
     * @param string $key
     * @return mixed
     */
    public function __get($key) {
        $constantName = get_class($this) . '::' . $key;
        if (defined($constantName)) {
            return constant($constantName);
        } else {
            trigger_error('Undefined property: ' . $constantName, E_USER_NOTICE);
        }
    }
}

if (DEBUG_MODE) {
    require configDefaults::basepath() . '.debug';
}

/**
 * Default configuration - these settings will only be used if they are not defined in the config file
 */
class configDefaults extends configInit {
    /**
     * Path to the config file, change only if not using the default file name/location
     * Note: if no DB connections or other configuration settings are needed the .config file can
     * be deleted and this setting will be ignored.
     */
    const CONFIG_PATH = '.config';

    /**
     * Optional, only need to set these if you wish to execute a file that is global to the
     * application before and/or after the page loads. Filename must match the class name and be in the MVC root.
     */
    const APP_CONSTRUCT = null, APP_DESTRUCT = null;

    /**
     * Optional, only need to set these in your config class if you move the folders from the default locations
     *
     * @var string
     */
    public $pathToMvc, $modelsFolder, $viewsFolder, $controllersFolder,
           $layoutsFolder, $elementsFolder, $componentsFolder, $helpersFolder;

    /**
     * Optional, only need to set this in your config class if the webroot folder is not installed in the root of
     * your web site directory
     *
     * @var string
     */
    public $basepath = '/';

    /**
     * Name of controller that is used to handle errors
     *
     * @var string
     */
    public $errorHandler = 'error';

    /**
     * By default no extension is used for MVC files, if you need to use a file extension then
     * it needs to be set it in your config class in order for the files to be found
     * and you need to include the prepended dot
     *
     * @var string
     */
    public $fileExtension = '';

    /**
     * These are the default helperes that will be loaded into every view (and available to every element)
     *
     * Default is 'html' and 'form'; you may wish to add more by overriding this property this
     * property within your config and adding the name of the additional helpers to the parent array.
     *
     * Note: only do this if most of your application needs the helper, otherwise you can load
     * helpers in the __construct of a controller or within any method (action) of a controller
     *
     * @var array
     */
    public $helpers = array('html', 'form');

    /**
     * This sets the objects that will be available to all your models, the default is db and
     * that should suffice for most applications. To add more create the object (class) in your config
     * and then override this property adding the name of your object to the parent array and add a static
     * property with the same name as the object to the config class (this will contain the object later.)
     */
    public static $db, $modelObjects = array('db');

    /**
     * Internal cache of basepath
     * @var string
     */
    protected static $_basepath;

    /**
     * Set the base working path
     * @return string
     */
    public static function basepath() {
        if (self::$_basepath === null) {
            if (isset($_SERVER['DOCUMENT_ROOT']) && $_SERVER['DOCUMENT_ROOT']) {
                $_SERVER['DOCUMENT_ROOT'] = rtrim($_SERVER['DOCUMENT_ROOT'], self::DS);
                self::$_basepath = (substr($_SERVER['DOCUMENT_ROOT'], -7) == 'webroot'
                                    ? substr($_SERVER['DOCUMENT_ROOT'], 0, -8) : $_SERVER['DOCUMENT_ROOT']) . self::DS;
            } else { //cli
                self::$_basepath = substr($_SERVER['SCRIPT_FILENAME'], 0, -12); //remove webroot/vork
            }
        }
        return self::$_basepath;
    }

    /**
     * Establishes MVC folder locations automatically
     */
    public function __construct() {
        is::$ajax = (isset($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest');
        if ($this->pathToMvc === null) {
            $this->pathToMvc = configDefaults::basepath() . 'mvc' . self::DS;
            if (isset($_SERVER['SCRIPT_NAME']) && $_SERVER['SCRIPT_NAME'] == '/webroot/vork') {
                $this->pathToMvc = $_SERVER['DOCUMENT_ROOT'] . self::DS . 'mvc' . self::DS;
            }
        } else {
            if (substr($this->pathToMvc, -1) != self::DS) { //append trailing slash if needed
                $this->pathToMvc .= self::DS;
            }
        }
        $mvcFolders = array('models', 'views', 'controllers',
                            'layouts', 'elements', 'components', 'helpers');
        foreach ($mvcFolders as $mvcFolder) {
            if ($this->{$mvcFolder . 'Folder'} === null) {
                $this->{$mvcFolder . 'Folder'} = $mvcFolder;
            }
        }
    }
}

/**
 * The internal MVC logic - essentially the brain of the framework
 */
class mvc {
    /**
     * Override these within your application to change controller, action, layout or view
     * You can also modify the params array as needed.
     * mvc::$controller = 'cart';
     * mvc::$action = 'logout';
     * mvc::$layout = 'mobile';
     * mvc::$view = 'confirmation';
     *
     * Changes to the above will only take affect after the current action returns, to make the affect
     * immediate (to redirect before completing the current action) simply add a return; statement right after.
     *
     * These properties have defaults set:
     * If no controller is defined in the URL then the index controller is used
     * If no action is defined in the URL then the index action is used
     * If no layout is defined in the controller then the default layout is used
     *
     * Views will always default to a file with the same name as the action and will first look within a
     * folder in the views directory that has the same name as the controller. If using the index action or
     * in the case that a controller is not found (usually for a page of semi-static content) and the folder
     * or the file within it is not found it will then look for a file in the root of the views
     * directory with the name of the controller.
     *
     * Acceptable locations are:
     * /mvc/views/controllerName/actionName
     * /mvc/views/controllerName
     *
     * To use a view from a different controller you can simply override the view setting within
     * your application and include the path:
     * mvc::$view = 'someOtherController' . get::$config->DS . 'newView';
     */
    public static $controller = 'index', $action = 'index', $layout = 'default', $view, $params = array();

    /**
     * This is a safety to prevent redirecting in infinite loops (eg. a redirects to b, then b redirects
     * back to a.) The default maximum redirects is 10 within one request, if you need more you could
     * increase this but keep in mind that any app that needs to redirect over 10 times per request
     * likely has some serious flaw in the architecture.
     */
    protected $_maxActionRedirects = 10, $_redirectHistory = array();

    /**
     * Buffer used to contain view params
     * @var array
     */
    protected static $_viewParams = array();

    /**
     * Replaces characters that are not valid within the name of a PHP object
     *
     * @param string $objName
     * @return string
     */
    protected function _getValidObjectName($objName) {
        $objName = preg_replace('/\W/', '_', $objName);
        if (is_numeric($objName[0])) { //cannot start with a number
            $objName = '_' . $objName;
        }
        return $objName;
    }

    /**
     * Load config, open a DB connection & cache (if they are defined,) parse the URL to determine controller/action
     * and then load the page
     */
    public function __construct() {
        if (is_file(configDefaults::basepath() . configDefaults::CONFIG_PATH)) {
            require configDefaults::basepath() . configDefaults::CONFIG_PATH;
            get::$config = new config;
        } else {
            get::$config = new configDefaults;
        }

        if (method_exists(get::$config, 'cache')) {
            get::$config->cache();
        }

        $this->_parseUrl();

        if (get::$config->APP_CONSTRUCT && is_file(get::$config->pathToMvc . get::$config->APP_CONSTRUCT)) {
            require get::$config->pathToMvc . get::$config->APP_CONSTRUCT;
            get::$config->{get::$config->APP_CONSTRUCT} = new get::$config->APP_CONSTRUCT;
        }

        $this->_loadAction(self::$controller, self::$action);

        if (get::$config->APP_DESTRUCT && is_file(get::$config->pathToMvc . get::$config->APP_DESTRUCT)) {
            require get::$config->pathToMvc . get::$config->APP_DESTRUCT;
            get::$config->{get::$config->APP_DESTRUCT} = new get::$config->APP_DESTRUCT;
        }
    }

    /**
     * Loads an element. Elements can access the view params plus the params sent to them as an argument as if
     * they are local variables. If there is a naming conflict the variable in the argument takes precedence.
     *
     * @param string $outputType
     * @param string $elementName
     * @param array $elementParams
     * @return mixed
     */
    protected static function _loadElement($outputType, $elementName, $elementParams) {
        $elementFile = get::mvcFilePath('elements', $elementName);
        if (is_file($elementFile)) {
            if (is_array(self::$_viewParams)) {
                extract(self::$_viewParams);
            }
            if (is_array($elementParams)) {
                extract($elementParams);
            }
            if (DEBUG_MODE) {
                $logMsg = 'element ' . $elementName . ' loaded';
                if ($elementParams) {
                    $logMsg .= ' with ' . json_encode($elementParams);
                }
            }
            if ($outputType == 'return') {
                ob_start();
                require $elementFile;
                $element = ob_get_contents();
                ob_end_clean();
                if (DEBUG_MODE) {
                    debug::log($logMsg);
                }
                return $element;
            } else {
                require $elementFile;
                if (DEBUG_MODE) {
                    debug::log($logMsg);
                }
            }
        } else {
            trigger_error('File for element ' . $elementName . ' could not be found', E_USER_WARNING);
        }
    }

    /**
     * Returns the output of an element as a string
     *
     * @param string $elementName
     * @param array $elementParams
     * @return string
     */
    public static function getElement($elementName, $elementParams = array()) {
        return self::_loadElement('return', $elementName, $elementParams);
    }

    /**
     * Loads an element, any output goes directly to stdout (echos to the screen)
     *
     * @param string $elementName
     * @param array $elementParams
     */
    public static function loadElement($elementName, $elementParams = array()) {
        self::_loadElement('echo', $elementName, $elementParams);
    }

    /**
     * Loads the default helpers defined in the config at every page instance
     */
    protected function _loadDefaultHelpers() {
        foreach (get::$config->helpers as $helper) {
            if (!isset(self::$_viewParams[$helper])) {
                $helperFile = get::mvcFilePath('helpers', $helper);
                if (is_file($helperFile)) {
                    if (!class_exists($helper . 'Helper')) {
                        require $helperFile;
                    }
                    $helperClassName = $helper . 'Helper';
                    get::$loadedObjects['helper'][$helper] = self::$_viewParams[$helper] = new $helperClassName;
                } else {
                    trigger_error('File for ' . $helperFile . ' helper could not be found', E_USER_WARNING);
                }
            }
        }
    }

    /**
     * Loads a view, if a layout exists then the view will be loaded into the layout
     *
     * @param string $controllerName
     * @param string $action
     * @return mixed
     */
    protected function _loadView($controllerName, $action) {
        if (!load::$loadView || self::$view === false) {
            return;
        }
        if (self::$view == null) { //try: /mvc/views/controllerName/actionName
            $viewFile = get::mvcFilePath('views', $controllerName . get::$config->DS . $action);
            if (!is_file($viewFile) && $action == 'index') { //try: /mvc/views/controllerName
                $viewFile = get::mvcFilePath('views', $controllerName);
            }
        } else {
            $viewFile = get::mvcFilePath('views', $controllerName . get::$config->DS . self::$view);
            if (!is_file($viewFile)) { //local path failed, try absolute path
                $viewFile = get::mvcFilePath('views', self::$view);
            }
        }

        if (!is_file($viewFile) && $controllerName != get::$config->errorHandler) {
            $controllerName = get::$config->errorHandler;
            $action = 'missingView';
            return $this->_loadAction($controllerName, $action);
        }

        if (is_array(self::$_viewParams)) {
            extract(self::$_viewParams);
        }

        if (is::$ajax && get::$config->ajaxEnabled
            && (!is_array(get::$config->ajaxEnabled) //ajax=true
                || (isset(get::$config->ajaxEnabled[$controllerName])
                    && (get::$config->ajaxEnabled[$controllerName] === true //ajax[controllerName]=true
                        || get::$config->ajaxEnabled[$controllerName] == $action //ajax[controllerName]=action
                        || (is_array(get::$config->ajaxEnabled[$controllerName]) //ajax[controllerName]=array(action)
                            && in_array($action, get::$config->ajaxEnabled[$controllerName])))))) {
            self::$layout = false; //AJAX request
        }

        $layoutFile = get::mvcFilePath('layouts', self::$layout);
        if (self::$layout && is_file($layoutFile)) {
            ob_start();
            require $viewFile;
            $view = ob_get_contents();
            ob_end_clean();
            require $layoutFile;
        } else {
            require $viewFile;
        }
    }

    /**
     * Loads an action
     *
     * @param string $controllerName
     * @param string $action
     * @return mixed
     */
    protected function _loadAction($controllerName, $action) {
        if (strpos($controllerName, '..') !== false || strpos($controllerName, ':') !== false) {
            $controllerName = get::$config->errorHandler;
            $action = 'invalidControllerName';
        }
        $action = $this->_getValidObjectName($action);
        if (!is_file(get::mvcFilePath('controllers', $controllerName))) { //no controller, attempt to load view directly
            $this->_loadDefaultHelpers();
            return $this->_loadView($controllerName, $action);
        }

        $controllerClassName = $controllerName . 'Controller';
        if (!class_exists($controllerClassName)) {
            require get::mvcFilePath('controllers', $controllerName);
        }
        if (!class_exists($controllerClassName) && $controllerName != get::$config->errorHandler) {
            $controllerName = get::$config->errorHandler;
            $action = 'controllerNotDefined';
            return $this->_loadAction($controllerName, $action);
        }

        $controller = new $controllerClassName;
        $optionalAction = defined($controllerName . 'Controller::optionalAction')
                                  && constant($controllerName . 'Controller::optionalAction');
        if (!$optionalAction) {
            self::$action = $action;
        }
        if (!method_exists($controller, $action) && $controllerName != get::$config->errorHandler) {
            if ($optionalAction && self::$action != 'index') {
                array_unshift(self::$params, self::$action);
                self::$action = 'index';
                return $this->_loadAction($controllerName, 'index');
            } else {
                $controllerName = get::$config->errorHandler;
                $action = 'missingAction';
                return $this->_loadAction($controllerName, $action);
            }
        }

        $this->_loadDefaultHelpers();
        $viewParams = $controller->$action();
        if (is_array($viewParams)) {
            self::$_viewParams = array_merge(self::$_viewParams, $viewParams);
        }

        if ($controllerName != get::$config->errorHandler) {
            $controllerBaseName = substr($controllerClassName, 0, -10);
            if (self::$controller != $controllerBaseName || self::$action != $action) {
                if (count($this->_redirectHistory) < $this->_maxActionRedirects) {
                    $this->_redirectHistory[] = array('oldController' => $controllerBaseName,
                                                      'newController' => self::$controller,
                                                      'oldAction' => $action,
                                                      'newAction' => self::$action);
                    return $this->_loadAction(self::$controller, self::$action);
                } else {
                    $controllerName = get::$config->errorHandler;
                    $action = 'redirectEndlessLooping';
                    self::$params['redirectHistory'] = $this->_redirectHistory;
                    return $this->_loadAction($controllerName, $action);
                }
            }
        }
        $this->_loadView($controllerName, $action);
    }

    /**
     * Parse URL string to extract controller name, action name and params
     */
    protected function _parseUrl() {
        $basepathLen = strlen(get::$config->basepath);
        if (isset($_SERVER['REQUEST_URI'])) {
            $path = substr($_SERVER['REQUEST_URI'], $basepathLen);
            $positionOfGet = strpos($path, '?');
            if ($positionOfGet !== false) {
                $path = substr($path, 0, $positionOfGet);
            }
            $pathParts = explode('/', $path);
            $fileName = (strrpos($_SERVER['SCRIPT_FILENAME'], get::$config->DS) + 1);
            if (isset($pathParts[0]) && $pathParts[0] == substr($_SERVER['SCRIPT_FILENAME'], $fileName)) {
                $firstSegment = array_shift($pathParts); //remove the current filename from the path parts;
                if ($firstSegment == 'vork' && get::$config->isSuperuser()) {
                    require configDefaults::basepath() . '.installer';
                }
            }
            foreach ($pathParts as $pathSegment) {
                $pathSegment = trim($pathSegment);
                if ($pathSegment != '') {
                    $pathSegments[] = $pathSegment;
                }
            }
        } else if (isset($_SERVER['argv'])) { //cli-mode
            $pathSegments = $_SERVER['argv'];
            array_shift($pathSegments);
        }

        if (isset($pathSegments) && $pathSegments) {
            self::$controller = $this->_getValidObjectName(array_shift($pathSegments));

            if (isset($pathSegments[0])) {
            self::$action = array_shift($pathSegments);
                if (!empty($pathSegments)) {
                    self::$params = $pathSegments;
                }
            }
        }
    }
}

/**
 * Blackhole object used when catching a database exception to avoid fatal errors being thrown before reaching
 * the error-handler controller & view.
 * Note: static database methods will still fatal-error in pre-5.3 versions of PHP as __callStatic was not yet supported
 */
class blackhole {
    public static function __callStatic($method, array $args) {
        return new blackhole;
    }
    public function __call($method, array $args) {
        return $this;
    }
    public function __get($name) {
        return $this;
    }
    public function __set($name, $val) {}
    public function __isset($name) {
        return false;
    }
    public function __unset($name) {}
    public function __toString() {
        return '';
    }
}

/**
 * Public interface to determine Boolean properties
 */
class is {
    /**
     * Opens up public access to config constants
     * @var object
     */
    public static $config;

    /**
     * If instance is requested via AJAX
     * @var Boolean
     */
    public static $ajax = false;
}

/**
 * Public interface to retrieve rendered elements and other objects
 */
class get {
    /**
     * Opens up public access to config constants and variables and the cache object
     * @var object
     */
    public static $config, $cache;

    /**
     * Index of objects loaded, used to maintain uniqueness of singletons
     * @var array
     */
    public static $loadedObjects = array();

    /**
     * Index of names of database-objects that have a connection open
     * @var array Keys are DB names, vals are always Bool true
     */
    protected static $_dbConnected = array();

    /**
     * Returns fully qualified path to an MVC file
     *
     * @param string $type
     * @param string $mvcName
     * @return string
     */
    public static function mvcFilePath($type, $mvcName) {
        return self::$config->pathToMvc . self::$config->{$type . 'Folder'}
             . self::$config->DS . $mvcName . self::$config->fileExtension;
    }

    /**
     * Gets the current URL
     *
     * @param mixed $ssl Boolean (true=https, false=http) or null (auto-selects the current protocol)
     * @param Boolean $noGet Adds the GET request if true
     * @return string
     */
    public static function url($ssl = null, $noGet = true) {
        if ($ssl === null) {
            $ssl = (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on');
        }
        if (!isset($_SERVER['HTTP_HOST']) && PHP_SAPI == 'cli') {
            $_SERVER['HTTP_HOST'] = trim(`hostname`);
            $argv = $_SERVER['argv'];
            array_shift($argv);
            $_SERVER['REDIRECT_URL'] = '/' . implode('/', $argv);
            $noGet = true; // command-line has no GET
        }
        return (!$ssl ? 'http://' : 'https://')
             . $_SERVER['HTTP_HOST'] . $_SERVER[$noGet ? 'REDIRECT_URL' : 'REQUEST_URI'];
    }

    /**
     * Initializes a database connection
     * @param string $db
     */
    public static function dbConnection($db) {
        if (!isset(self::$_dbConnected[$db]) && method_exists(self::$config, 'dbConnect')) {
            try {
                self::$config->dbConnect($db);
                self::$_dbConnected[$db] = true;
            } catch (Exception $e) {
                mvc::$params = $e;
                mvc::$controller = get::$config->errorHandler;
                mvc::$action = 'DatasourceError';
                config::$$db = new blackhole;
            }
        }
    }

    /**
     * Loads an object as a singleton
     *
     * @param string $objectType
     * @param string $objectName
     * @return object
     */
    protected static function _loadObject($objectType, $objectName) {
        if ($objectName == null) {
            $objectName = mvc::$controller;
        }
        if (isset(self::$loadedObjects[$objectType][$objectName])) {
            return self::$loadedObjects[$objectType][$objectName];
        }
        $objectFile = self::mvcFilePath($objectType . 's', $objectName);
        if (is_file($objectFile)) {
            require $objectFile;
            $objectClassName = $objectName . ucfirst($objectType);
            if (class_exists($objectClassName)) {
                $objectObject = new $objectClassName;
                if ($objectType == 'model' && config::MODEL_AUTOCONNECT) {
                    foreach (config::$modelObjects as $modelObject) {
                        self::dbConnection($modelObject);
                        $objectObject->$modelObject = config::$$modelObject;
                    }
                }
                self::$loadedObjects[$objectType][$objectName] = $objectObject;
                if (DEBUG_MODE) {
                    debug::log($objectType . ' ' . $objectName . ' loaded');
                }
                return $objectObject;
            } else {
                $errorMsg = 'Class for ' . $objectType . ' ' . $objectName . ' could not be found';
            }
        } else {
            $errorMsg = 'File for ' . $objectType . ' ' . $objectName . ' could not be found';
        }
        trigger_error($errorMsg, E_USER_WARNING);
    }

    /**
     * Returns a model object
     *
     * @param string $model
     * @return object
     */
    public static function model($model = null) {
        return self::_loadObject('model', $model);
    }

    /**
     * Returns a component object
     *
     * @param string $model
     * @return object
     */
    public static function component($component = null) {
        return self::_loadObject('component', $component);
    }

    /**
     * Returns a helper object
     *
     * @param string $model
     * @return object
     */
    public static function helper($helper) {
        if (is_array($helper)) {
            array_walk($helper, array('self', __METHOD__));
            return;
        }
        if (!in_array($helper, self::$config->helpers)) {
            self::$config->helpers[] = $helper;
        }
        return self::_loadObject('helper', $helper);
    }

    /**
     * Renders an element and returns the results as a string
     *
     * @param string $element
     * @param array $params
     */
    public static function element($element, $params = array()) {
        $elementId = $element . $paramsString = serialize($params);
        if (!isset(self::$loadedObjects['element'][$elementId])) {
            self::$loadedObjects['element'][$elementId] = mvc::getElement($element, $params);
        }
        return self::$loadedObjects['element'][$elementId];
    }

    /**
     * Overloads the php function htmlentities and changes the default charset to UTF-8 and the default value for the
     * fourth parameter $doubleEncode to false. Also adds ability to pass a null value to get the default $quoteStyle
     * and $charset (removes need to repeatedly define ENT_COMPAT, 'UTF-8', just to access the $doubleEncode argument)
     *
     * If you are using a PHP version prior to 5.2.3 the $doubleEncode parameter is not available so you will need
     * to comment out the last parameter in the return clause (including the preceding comma)
     *
     * @param string $string
     * @param int $quoteStyle Uses ENT_COMPAT if null or omitted
     * @param string $charset Uses UTF-8 if null or omitted
     * @param boolean $doubleEncode
     * @return string
     */
    public static function htmlentities($string, $quoteStyle = ENT_COMPAT, $charset = 'UTF-8', $doubleEncode = false) {
        return htmlentities($string, (!is_null($quoteStyle) ? $quoteStyle : ENT_COMPAT),
                            (!is_null($charset) ? $charset : 'UTF-8'), $doubleEncode);
    }

    /**
     * Initialize the character maps needed for the xhtmlentities() method and verifies the argument values
     * passed to it are valid.
     *
     * @param int $quoteStyle
     * @param string $charset Only valid options are UTF-8 and ISO-8859-1 (Latin-1)
     * @param boolean $doubleEncode
     */
    protected static function initXhtmlentities($quoteStyle, $charset, $doubleEncode) {
        $chars = get_html_translation_table(HTML_ENTITIES, $quoteStyle);
        if (isset($chars)) {
            unset($chars['<'], $chars['>']);
            $charMaps[$quoteStyle]['ISO-8859-1'][true] = $chars;
            $charMaps[$quoteStyle]['ISO-8859-1'][false] = array_combine(array_values($chars), $chars);
            $charMaps[$quoteStyle]['UTF-8'][true] = array_combine(array_map('utf8_encode', array_keys($chars)), $chars);
            $charMaps[$quoteStyle]['UTF-8'][false] = array_merge($charMaps[$quoteStyle]['ISO-8859-1'][false],
                                                                 $charMaps[$quoteStyle]['UTF-8'][true]);
            self::$loadedObjects['xhtmlEntities'] = $charMaps;
        }
        if (!isset($charMaps[$quoteStyle][$charset][$doubleEncode])) {
            if (!isset($chars)) {
                $invalidArgument = 'quoteStyle = ' . $quoteStyle;
            } else if (!isset($charMaps[$quoteStyle][$charset])) {
                $invalidArgument = 'charset = ' . $charset;
            } else {
                $invalidArgument = 'doubleEncode = ' . (string) $doubleEncode;
            }
            trigger_error('Undefined argument sent to xhtmlentities() method: ' . $invalidArgument, E_USER_NOTICE);
        }
    }

    /**
     * Converts special characters in a string to XHTML-valid ASCII encoding the same as htmlentities except
     * this method allows the use of HTML tags within your string. Signature is the same as htmlentities except
     * that the only character sets available (third argument) are UTF-8 (default) and ISO-8859-1 (Latin-1).
     *
     * @param string $string
     * @param int $quoteStyle Constants available are ENT_NOQUOTES (default), ENT_QUOTES, ENT_COMPAT
     * @param string $charset Only valid options are UTF-8 (default) and ISO-8859-1 (Latin-1)
     * @param boolean $doubleEncode Default is false
     * @return string
     */
    public static function xhtmlentities($string, $quoteStyle = ENT_NOQUOTES, $charset = 'UTF-8',
                                         $doubleEncode = false) {
        $quoteStyles = array(ENT_NOQUOTES, ENT_QUOTES, ENT_COMPAT);
        $quoteStyle = (!in_array($quoteStyle, $quoteStyles) ? current($quoteStyles) : $quoteStyle);
        $charset = ($charset != 'ISO-8859-1' ? 'UTF-8' : $charset);
        $doubleEncode = (Boolean) $doubleEncode;
        if (!isset(self::$loadedObjects['xhtmlEntities'][$quoteStyle][$charset][$doubleEncode])) {
            self::initXhtmlentities($quoteStyle, $charset, $doubleEncode);
        }
        return strtr($string, self::$loadedObjects['xhtmlEntities'][$quoteStyle][$charset][$doubleEncode]);
    }
}

/**
 * Abstract class to extend model functionality (usage is optional, model functionality is not dependent on this)
 */
abstract class model {
    /**
     * Enables true lazy-loading of database connections when config::MODEL_AUTOCONNECT is set to false and each
     * model extends this class
     *
     * @param string $var
     * @return object
     */
    public function __GET($var) {
        get::dbConnection($var);
        return $this->$var = config::$$var;
    }
}

class cache {
    /**
     * Public access to the cache object
     * @return obj
     */
    public function __construct() {
        return get::$cache;
    }

    /**
     * Static wrapper for the caching methods
     *
     * @param str $method
     * @param array $args
     * @return mixed
     */
    public static function __callStatic($method, array $args) {
        return call_user_func_array(array(get::$cache, $method), $args);
    }

    /**
     * Automates caching of a function or method result
     *
     * @param str $id
     * @param mixed $method
     * @param array $args
     * @param int $expires
     * @return mixed
     */
    public static function method($id, $method, array $args = array(), $flag = null, $expires = null) {
        $return = get::$cache->get($id);
        if ($return === false) {
            $return = call_user_func_array($method, $args);
            get::$cache->set($id, $return, $flag, $expires);
        }
        return $return;
    }

    /**
     * The next bunch of methods are workarounds for lack of __callStatic(), they can be safely removed in PHP 5.3+
     * @deprecated
     */
    public static function get() {
        $args = func_get_args();
        return call_user_func_array(array(get::$cache, __FUNCTION__), $args);
    }
    public static function set() {
        $args = func_get_args();
        return call_user_func_array(array(get::$cache, __FUNCTION__), $args);
    }
    public static function delete() {
        $args = func_get_args();
        return call_user_func_array(array(get::$cache, __FUNCTION__), $args);
    }
    public static function flush() {
        $args = func_get_args();
        return call_user_func_array(array(get::$cache, __FUNCTION__), $args);
    }
}

/**
 * Public interface to load elements and cause redirects
 */
class load {
    /**
     * Flag set to false to supress loading a view; used when the user is redirected
     * @var boolean
     */
    public static $loadView = true;

    /**
     * Sends a redirects header and disables view rendering
     * This redirects via a browser command, this is not the same as changing controllers which is handled within MVC
     *
     * @param string $url Optional, if undefined this will refresh the page (mostly useful for dumping post values)
     */
    public static function redirect($url = null) {
        self::$loadView = false;
        header('Location: ' . ($url ? $url : get::url(null, false)));
    }

    /**
     * Loads an element to STDOUT
     *
     * @param string $element
     * @param array $params
     */
    public static function element($element, $params = array()) {
        mvc::loadElement($element, $params);
    }
}

if (!defined('DONT_AUTOSTART_VORK')) {
    new mvc;
}